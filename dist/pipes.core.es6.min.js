this.Pipes=this.Pipes||{},function(e){"use strict";function n(e,n,t){let r=[];for(;n.length&&t.length;)r.push(e(n.pop(),t.pop()));return r}function t(e){return e?(e^16*Math.random()>>e/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,t)}function r(e,n){if(!T(e))throw new Error(F);class t{constructor(){let t,r,o,i,u,a=n,f=!1;o=new Promise((e,n)=>{i=e;u=n}),r=new g({start(e){o.catch(u)},write(n){a=void 0!==a?e(a,n):n},close(){i(a)},abort:u}),t=new b({start(e){o.then(n=>{f||e.enqueue(n)},e.error.bind(e)).then(e.close.bind(e))},cancel(e){f=!0,r&&r.close(),i(e)}}),Object.assign(this,{readable:t,writable:r})}}return this instanceof r?new t:t}function o(e,...n){if(!e)throw new Error("No streams passed");let t,r;t=n.pop(),r=e instanceof b?e:e.readable;for(let e of n){if(!_(e))throw new Error("Only transform streams allowed in the center");r=r.pipeThrough(e)}if(q(t))r=r.pipeTo(t);else{if(!_(t))throw new Error("Only writable and transform streams allowed at the end.");r=r.pipeThrough(t)}return r}function i(e,...n){if(!_(e))throw new Error(W);const{writable:t}=e,r=O(e,...n);if(!P(r))throw new Error(W);return{readable:r,writable:t}}function u(...e){let t,r=[];return t=new b({start(t){for(;r.length<e.length;)r.push(new g({write:t.enqueue.bind(t)}));let o,i=(e,n)=>e.pipeTo(n);try{o=n(i,e,r)}catch(e){throw new Error("Only readable streams can be flattened.")}return Promise.all(o).then(t.close.bind(t),t.error.bind(t))},cancel(){e.forEach(e=>e.cancel())}})}function a(e){let n=!1,t=[];for(let r of e){if(null==r)break;let{value:e,done:o}=r;n=n||o,t.push(e)}return{value:t,done:n}}function f(...e){let n,t,r;try{n=e.map(e=>e.getReader())}catch(e){throw new Error("Only ReadableStreams can be flattened")}return r=(e=>{let t,r,o=n.map(e=>e.read());r=(n=>{let{value:t,done:r}=n;if(r)return e.close();e.enqueue(t);return n});t=Promise.all(o).then(a).then(r,e.error.bind(e));return t}),t=new b({start:r,pull:r,cancel(){e.forEach(e=>e.cancel())}})}function c(e,{init:n,readableStrategy:t,writableStrategy:r}={}){let o={_unfulfilledFutures:[],transform(n,t){let r=e(n),i=e=>{if(e===S)return void t.close();void 0!==e&&t.enqueue(e)},u=o._unfulfilledFutures.length;return o._unfulfilledFutures.push(r),r.then(i,()=>{throw new Error}).then(()=>o._unfulfilledFutures.splice(u,1)),r},flush(e){let n=n=>{void 0!==n&&e.enqueue(n)};Promise.all(o._unfulfilledFutures).then(e=>e.map(n))},readableStrategy:t,writableStrategy:r};class i extends y{constructor(){let e,t=super(o);return void 0!==n&&((e=t.writable.getWriter()).write(n),e.releaseLock()),t}}return this instanceof c?new i:i}function l(e,{init:n,readableStrategy:t,writableStrategy:r}={}){let o={_unfulfilledFutures:[],transform(n,t){let r=e(n);r!==S?void 0!==r&&t.enqueue(r):t.close()},readableStrategy:t,writableStrategy:r};class i extends y{constructor(){let e,t=super(o);return void 0!==n&&((e=t.writable.getWriter()).write(n),e.releaseLock()),t}}return i}function s(e,n,t){if(E.off(R),n.desiredSize<=0)return E.on(R,()=>{s(e,n,t)});let r=n[L]?e.return(!0):e.next(!1),{done:o,value:i}=r;return i===S?(n.close(),o=!0):n.enqueue(i),o?t&&t():s(e,n,t)}function d(e,{init:n,readableStrategy:t,writableStrategy:r}={}){return class{constructor(){let o,i,u,a,f;if(u=new Promise(e=>{a=e}),i=new g({start(){return u},write(n,t){let r,o;return r=new Promise(e=>{o=e}),s(e(n),f,o),r},close(){try{f.close()}catch(e){if(!(e instanceof TypeError))throw e}finally{f[L]=!0}}},r),o=new b({start(e){(f=e)[L]=!1,a()},pull(){E.trigger(R)},cancel(e){i._write.close(),f[L]=!0}},t),void 0!==n){let e=i.getWriter();e.write(n),e.releaseLock()}this.readable=o,this.writable=i}}}function h(e,n){let t;if(x(e))t=d(e,n);else{if(!T(e))throw new Error("Invalid argument");t=l(e,n)}return this instanceof h?new t:t}function p(e,n=2){if(!e.tee)throw new Error("Only readable streams can be split");let t,r,o;for(t=[e];n>t.length;){let e=t.pop();t=t.concat(e.tee())}return r=t.map(e=>e.cancel.bind(e)),o=(()=>r.forEach(e=>e())),t.forEach(e=>{e.cancelAll=o}),t}let w,m=m||{};if("undefined"!=typeof window&&(m=window),m.ReadableStream)w={ReadableStream:m.ReadableStream,WritableStream:m.WritableStream,ByteLengthQueuingStrategy:m.ByteLengthQueuingStrategy,CountQueuingStrategy:m.CountQueuingStrategy,TransformStream:m.TransformStream};else try{w=require("web-streams-polyfill"),console.log(JSON.stringify(w,null,4))}catch(e){throw new Error("No Stream implementation found")}const b=w.ReadableStream,g=w.WritableStream,y=w.TransformStream,S=Symbol.for("pipe.eos");class v{constructor(){this._events={}}trigger(e,...n){e in this._events&&this._events[e].forEach(e=>e(...n))}on(e,n){this._events[e]=this._events[e]||[],this._events[e].push(n)}off(e){this._events[e]=[]}}const E=new v,_=e=>e&&e.writable&&e.readable,P=e=>e instanceof b&&e.pipeThrough,q=e=>e instanceof g&&e.getWriter,T=e=>"function"==typeof e,x=({constructor:e})=>e&&("GeneratorFunction"===e.name||"GeneratorFunction"===e.displayName),F=`\n    accumulate takes a reducing function\n  `;"undefined"!=typeof module&&(module.exports=r);const O=o;o._connect=o,"undefined"!=typeof module&&(module.exports=o);const W=`\n    Only transform streams and readable-writable pairs can be chained\n  `;"undefined"!=typeof module&&(module.exports=i),"undefined"!=typeof module&&(module.exports=u),f._merge=f,"undefined"!=typeof module&&(module.exports=f);const R=t(),L=t();h.async=c,h.eos=S,"undefined"!=typeof module&&(module.exports=h),"undefined"!=typeof module&&(module.exports=p);try{require("babel-polyfill")}catch(e){console.error("babel-polyfill not loaded. "+e.toString())}const k={accumulate:r,connect:o,chain:i,flatten:u,merge:f,pipe:h,split:p};"undefined"!=typeof window&&Object.assign(window,{Pipes:k}),e.accumulate=r,e.connect=o,e.chain=i,e.flatten=u,e.merge=f,e.pipe=h,e.split=p,e.default=k}(this.Pipes.core=this.Pipes.core||{});
