function zipWith(e,n,t){let r=[];for(;n.length&&t.length;)r.push(e(n.pop(),t.pop()));return r}function uuid(e){return e?(e^16*Math.random()>>e/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,uuid)}function accumulate(e,n){if(!isFunction(e))throw new Error(compatibilityError);class t{constructor(){let t,r,i,o,a,u=n,l=!1;i=new Promise((e,n)=>{o=e;a=n}),r=new WritableStream({start(e){i.catch(a)},write(n){u=void 0!==u?e(u,n):n},close(){o(u)},abort:a}),t=new ReadableStream({start(e){i.then(n=>{l||e.enqueue(n)},e.error.bind(e)).then(e.close.bind(e))},cancel(e){l=!0,r&&r.close(),o(e)}}),Object.assign(this,{readable:t,writable:r})}}return this instanceof accumulate?new t:t}function connect(e,...n){if(!e)throw new Error("No streams passed");let t,r;t=n.pop(),r=e instanceof ReadableStream?e:e.readable;for(let e of n){if(!isTransform(e))throw new Error("Only transform streams allowed in the center");r=r.pipeThrough(e)}if(isWritable(t))r=r.pipeTo(t);else{if(!isTransform(t))throw new Error("Only writable and transform streams allowed at the end.");r=r.pipeThrough(t)}return r}function chain(e,...n){if(!isTransform(e))throw new Error(compatibilityError$1);const{writable:t}=e,r=_connect(e,...n);if(!isReadable(r))throw new Error(compatibilityError$1);return{readable:r,writable:t}}function flatten(...e){let n,t=[];return n=new ReadableStream({start(n){for(;t.length<e.length;)t.push(new WritableStream({write:n.enqueue.bind(n)}));let r,i=(e,n)=>e.pipeTo(n);try{r=zipWith(i,e,t)}catch(e){throw new Error("Only readable streams can be flattened.")}return Promise.all(r).then(n.close.bind(n),n.error.bind(n))},cancel(){e.forEach(e=>e.cancel())}})}function parseResults(e){let n=!1,t=[];for(let r of e){if(null==r)break;let{value:e,done:i}=r;n=n||i,t.push(e)}return{value:t,done:n}}function merge(...e){let n,t,r;try{n=e.map(e=>e.getReader())}catch(e){throw new Error("Only ReadableStreams can be flattened")}return r=(e=>{let t,r,i=n.map(e=>e.read());r=(n=>{let{value:t,done:r}=n;if(r)return e.close();e.enqueue(t);return n});t=Promise.all(i).then(parseResults).then(r,e.error.bind(e));return t}),t=new ReadableStream({start:r,pull:r,cancel(){e.forEach(e=>e.cancel())}})}function pipeAsync(e,{init:n,readableStrategy:t,writableStrategy:r}={}){let i={_unfulfilledFutures:[],transform(n,t){let r=e(n),o=e=>{if(e===EOS)return void t.close();void 0!==e&&t.enqueue(e)},a=i._unfulfilledFutures.length;return i._unfulfilledFutures.push(r),r.then(o,()=>{throw new Error}).then(()=>i._unfulfilledFutures.splice(a,1)),r},flush(e){let n=n=>{void 0!==n&&e.enqueue(n)};Promise.all(i._unfulfilledFutures).then(e=>e.map(n))},readableStrategy:t,writableStrategy:r};class o extends TransformStream{constructor(){let e,t=super(i);return void 0!==n&&((e=t.writable.getWriter()).write(n),e.releaseLock()),t}}return this instanceof pipeAsync?new o:o}function pipeFn(e,{init:n,readableStrategy:t,writableStrategy:r}={}){let i={_unfulfilledFutures:[],transform(n,t){let r=e(n);r!==EOS?void 0!==r&&t.enqueue(r):t.close()},readableStrategy:t,writableStrategy:r};class o extends TransformStream{constructor(){let e,t=super(i);return void 0!==n&&((e=t.writable.getWriter()).write(n),e.releaseLock()),t}}return o}function pump(e,n,t){if(events.off(readyEvt),n.desiredSize<=0)return events.on(readyEvt,()=>{pump(e,n,t)});let r=n[closedProp]?e.return(!0):e.next(!1),{done:i,value:o}=r;return o===EOS?(n.close(),i=!0):n.enqueue(o),i?t&&t():pump(e,n,t)}function pipeGen(e,{init:n,readableStrategy:t,writableStrategy:r}={}){return class{constructor(){let i,o,a,u,l;if(a=new Promise(e=>{u=e}),o=new WritableStream({start(){return a},write(n,t){let r,i;return r=new Promise(e=>{i=e}),pump(e(n),l,i),r},close(){try{l.close()}catch(e){if(!(e instanceof TypeError))throw e}finally{l[closedProp]=!0}}},r),i=new ReadableStream({start(e){(l=e)[closedProp]=!1,u()},pull(){events.trigger(readyEvt)},cancel(e){o._write.close(),l[closedProp]=!0}},t),void 0!==n){let e=o.getWriter();e.write(n),e.releaseLock()}this.readable=i,this.writable=o}}}function pipe(e,n){let t;if(isGeneratorFn(e))t=pipeGen(e,n);else{if(!isFunction(e))throw new Error("Invalid argument");t=pipeFn(e,n)}return this instanceof pipe?new t:t}function split(e,n=2){if(!e.tee)throw new Error("Only readable streams can be split");let t,r,i;for(t=[e];n>t.length;){let e=t.pop();t=t.concat(e.tee())}return r=t.map(e=>e.cancel.bind(e)),i=(()=>r.forEach(e=>e())),t.forEach(e=>{e.cancelAll=i}),t}let interfaces,global=global||{};if("undefined"!=typeof window&&(global=window),global.ReadableStream)interfaces={ReadableStream:global.ReadableStream,WritableStream:global.WritableStream,ByteLengthQueuingStrategy:global.ByteLengthQueuingStrategy,CountQueuingStrategy:global.CountQueuingStrategy,TransformStream:global.TransformStream};else try{interfaces=require("web-streams-polyfill"),console.log(JSON.stringify(interfaces,null,4))}catch(e){throw new Error("No Stream implementation found")}const ReadableStream=interfaces.ReadableStream,WritableStream=interfaces.WritableStream,TransformStream=interfaces.TransformStream,EOS=Symbol.for("pipe.eos");class Events{constructor(){this._events={}}trigger(e,...n){e in this._events&&this._events[e].forEach(e=>e(...n))}on(e,n){this._events[e]=this._events[e]||[],this._events[e].push(n)}off(e){this._events[e]=[]}}const events=new Events,isTransform=e=>e&&e.writable&&e.readable,isReadable=e=>e instanceof ReadableStream&&e.pipeThrough,isWritable=e=>e instanceof WritableStream&&e.getWriter,isFunction=e=>"function"==typeof e,isGenerator=e=>e&&isFunction(e.next),isGeneratorFn=({constructor:e})=>e&&("GeneratorFunction"===e.name||"GeneratorFunction"===e.displayName),compatibilityError=`\n    accumulate takes a reducing function\n  `;"undefined"!=typeof module&&(module.exports=accumulate);const _connect=connect;connect._connect=connect,"undefined"!=typeof module&&(module.exports=connect);const compatibilityError$1=`\n    Only transform streams and readable-writable pairs can be chained\n  `;"undefined"!=typeof module&&(module.exports=chain),"undefined"!=typeof module&&(module.exports=flatten),merge._merge=merge,"undefined"!=typeof module&&(module.exports=merge);const readyEvt=uuid(),closedProp=uuid();pipe.async=pipeAsync,pipe.eos=EOS,"undefined"!=typeof module&&(module.exports=pipe),"undefined"!=typeof module&&(module.exports=split);try{require("babel-polyfill")}catch(e){console.error("babel-polyfill not loaded. "+e.toString())}const fns={accumulate:accumulate,connect:connect,chain:chain,flatten:flatten,merge:merge,pipe:pipe,split:split};"undefined"!=typeof window&&Object.assign(window,{Pipes:fns});export{accumulate,connect,chain,flatten,merge,pipe,split};export default fns;
